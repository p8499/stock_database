CREATE OR REPLACE FUNCTION FM11_BEFORE()
  RETURNS TRIGGER AS $$
  DECLARE
    fi_found INTEGER;
    fi FS12%ROWTYPE;
  BEGIN
    --最近的财报
    SELECT * INTO fi FROM FS12 t0 WHERE t0.FISTID = NEW.D1STID AND t0.FIPUBLISH <= NEW.D1DATE
      AND NOT EXISTS (SELECT 1 FROM FS12 t1 WHERE t1.FISTID = NEW.D1STID AND t1.FIPUBLISH <= NEW.D1DATE AND t1.FIPUBLISH > t0.FIPUBLISH);
    GET DIAGNOSTICS fi_found := ROW_COUNT;
	IF fi_found = 1 THEN
      NEW.D1FINA := fi.FINA;
	  NEW.D1FIOIY := fi.FIOIY;
	  NEW.D1FINPEY := fi.FINPEY;
	  NEW.D1FIOCNY := fi.FIOCNY;
      NEW.D1FINAPS := fi.FINA / NEW.D1TOTALSHARE;
	  NEW.D1FIOIYPS := fi.FIOIY / NEW.D1TOTALSHARE;
	  NEW.D1FINPEYPS := fi.FINPEY / NEW.D1TOTALSHARE;
	  NEW.D1FIOCNYPS := fi.FIOCNY / NEW.D1TOTALSHARE;
	  NEW.D1PB := CASE WHEN fi.FINA <> 0 THEN NEW.D1CLOSE / fi.FINA * NEW.D1TOTALSHARE ELSE NULL END;
	  NEW.D1PS := CASE WHEN fi.FIOIY <> 0 THEN NEW.D1CLOSE / fi.FIOIY * NEW.D1TOTALSHARE ELSE NULL END;
	  NEW.D1PE := CASE WHEN fi.FINPEY <> 0 THEN NEW.D1CLOSE / fi.FINPEY * NEW.D1TOTALSHARE ELSE NULL END;
	  NEW.D1PCF := CASE WHEN fi.FIOCNY <> 0 THEN NEW.D1CLOSE / fi.FIOCNY * NEW.D1TOTALSHARE ELSE NULL END;
    END IF;
    --返回
    RETURN NEW;
  END;
$$
LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS FM11_BEFORE_INSERT ON FM11;
CREATE TRIGGER FM11_BEFORE_INSERT BEFORE INSERT ON FM11 FOR EACH ROW EXECUTE PROCEDURE FM11_BEFORE();
